variables:
  IMAGE_NAME: buffalo147/dev-apps
  IMAGE_TAG: movie-app

stages:
  - build
  - deploy

  
build:
  stage: build
  image: quay.io/buildah/stable:latest
  variables:
    STORAGE_DRIVER: vfs
    BUILDAH_FORMAT: docker
  before_script:
    - buildah login -u "$REGISTRY_USER" -p "$REGISTRY_PASS" docker.io
  script:
    - |
      # Create manifest list
      buildah manifest create $IMAGE_NAME:$IMAGE_TAG
      
      # Build and add amd64
      buildah bud \
        --arch=amd64 \
        --timestamp 0 \
        --manifest $IMAGE_NAME:$IMAGE_TAG \
        -f Dockerfile .
      
      # Build and add arm64
      buildah bud \
        --arch=arm64 \
        --timestamp 0 \
        --manifest $IMAGE_NAME:$IMAGE_TAG \
        -f docker/Dockerfile .
      
      # Push the manifest list
      buildah manifest push --all \
        $IMAGE_NAME:$IMAGE_TAG \
        docker://$IMAGE_NAME:$IMAGE_TAG

# debug_ssh:
#   stage: deploy
#   image: alpine:latest
#   before_script:
#     - apk add --no-cache openssh-client  # Keep only necessary package
#     - mkdir -p ~/.ssh
#     - cp "$SSH_KEY" ~/.ssh/id_rsa
#     - chmod 400 ~/.ssh/id_rsa
#   script:
#     # Replace 'file' command with safer alternatives:
#     - echo "Verifying SSH key:"
#     - head -n 1 ~/.ssh/id_rsa | grep -q "BEGIN" && echo "Valid key header found" || echo "Invalid key format"
#     - head -n 5 ~/.ssh/id_rsa  # Original verification command

# deploy:
#   stage: deploy
#   image: alpine:latest # better base image for ssh support
#   before_script:
#     - apk add --no-cache openssh-client
#     - mkdir -p ~/.ssh
#     - cp "$SSH_KEY" ~/.ssh/id_rsa
#     - chmod 400 ~/.ssh/id_rsa
#   script:
#     - echo "Deploying containerized app..."
#     # We will pass the necessary variables into the remote SSH session
#     - |
#       ssh -o StrictHostKeyChecking=no -i ~/.ssh/id_rsa root@$SERVER "\
#         REMOTE_IMAGE_NAME='$IMAGE_NAME'; \
#         REMOTE_IMAGE_TAG='$IMAGE_TAG'; \
#         REMOTE_REGISTRY_USER='$REGISTRY_USER'; \
#         REMOTE_REGISTRY_PASS='$REGISTRY_PASS'; \
#         \
#         docker login -u \"\$REMOTE_REGISTRY_USER\" -p \"\$REMOTE_REGISTRY_PASS\" && \
#         docker pull \"\$REMOTE_IMAGE_NAME:\$REMOTE_IMAGE_TAG\" && \
#         docker stop movie-app || true && \
#         docker rm movie-app || true && \
#         docker run -d \
#           --name movie-app \
#           --label 'traefik.enable=true' \
#           --label "traefik.http.routers.movie.rule=Host(\\`stream.kwadwolabs.cloud\\`)" \ 
#           --label 'traefik.http.routers.movie.entrypoints=websecure' \
#           --label 'traefik.http.routers.movie.tls.certresolver=myresolver' \
#           --label 'traefik.http.services.movie.loadbalancer.server.port=80' \
#           "\"\$REMOTE_IMAGE_NAME:\$REMOTE_IMAGE_TAG\""
#       "

# deploy:
#   stage: deploy
#   image: alpine:latest
#   before_script:
#     - apk add --no-cache openssh-client
#     - mkdir -p ~/.ssh
#     - cp "$SSH_KEY" ~/.ssh/id_rsa
#     - chmod 400 ~/.ssh/id_rsa
#   script:
#     - echo "Copying docker-compose.yml and .env to server..."
#     - scp -o StrictHostKeyChecking=no -i ~/.ssh/id_rsa docker-compose.yml root@$SERVER:/root/movieapp/
#     - scp -o StrictHostKeyChecking=no -i ~/.ssh/id_rsa .env root@$SERVER:/root/movieapp/
#     - echo "Deploying containerized app..."
#     - |
#       ssh -o StrictHostKeyChecking=no -i ~/.ssh/id_rsa root@$SERVER "\
#         export IMAGE_NAME='$IMAGE_NAME'; \
#         export IMAGE_TAG='$IMAGE_TAG'; \
#         export REGISTRY_USER='$REGISTRY_USER'; \
#         export REGISTRY_PASS='$REGISTRY_PASS'; \
#         \
#         cd /root/movieapp && \
#         docker login -u \"\$REGISTRY_USER\" -p \"\$REGISTRY_PASS\" && \
#         docker pull \"\$IMAGE_NAME:\$IMAGE_TAG\" && \
#         docker compose down -v || true && \
#         docker compose up -d
#       "

deploy:
  stage: deploy
  tags:
    - deploy
    - kls
  image:
    name: alpine:latest
    entrypoint: [""]
  variables:
    IMAGE: "$IMAGE_NAME:$IMAGE_TAG"  
  before_script:
    - apk add --no-cache curl
    - curl -LO "https://dl.k8s.io/release/v1.32.0/bin/linux/amd64/kubectl"
    - chmod +x kubectl
    - mv kubectl /usr/local/bin/
  script:
    # Create kubeconfig file from env var
    - echo "$KUBE_CONFIG" | base64 -d > kubeconfig
    - export KUBECONFIG=$PWD/kubeconfig
    - kubectl version 
    - sed -i "s|IMAGE_PLACEHOLDER|$IMAGE|g" k8s/deployment.yaml
    - kubectl apply -f k8s/